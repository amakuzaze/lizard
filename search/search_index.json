{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lizard \u00b6 Lizard is a domain-specific language to define hardware behavior. It is intended to run on embedded systems which are connected to motor controllers, sensors etc. Most of the time it is used in combination with a higher level engine like ROS or RoSys . You can think of the microcontroller as the machine's lizard brain which ensures basic safety and performs all time-critical actions. Features \u00b6 Shell-like input and output over serial communication to ease the development Quick and resource-efficient execution on embedded hardware Built-in checksums to detect transmission errors Safety conditions that are checked continuously Ability to work across multiple microcontrollers Human-readable and easy-to-type (like Python) Concept \u00b6 Lizard consists of individual hardware modules that are either defined in a persistent startup script or interactively via console input. Each module has a name, a number of required or optional constructor arguments and possibly a step function as well as a number of properties. Furthermore, Lizard allows to define rules , possibly asynchronous routines and variables . A routine is simply a collection of Lizard statements. If a rule's condition evaluates to true, the corresponding routine is started. Conditions can involve variables, module properties and constant expressions. One core module is automatically defined first. It provides interaction with the microcontroller itself, e.g. reading the system's time or causing a restart. During a main loop Lizard repeatedly performs the following tasks: Read and evaluate input from the serial interface. Run the step functions of each module. (The core module is evaluated last.) Check all rules and execute associated routines. Advance routines that are already running and waiting for certain conditions.","title":"About"},{"location":"#lizard","text":"Lizard is a domain-specific language to define hardware behavior. It is intended to run on embedded systems which are connected to motor controllers, sensors etc. Most of the time it is used in combination with a higher level engine like ROS or RoSys . You can think of the microcontroller as the machine's lizard brain which ensures basic safety and performs all time-critical actions.","title":"Lizard"},{"location":"#features","text":"Shell-like input and output over serial communication to ease the development Quick and resource-efficient execution on embedded hardware Built-in checksums to detect transmission errors Safety conditions that are checked continuously Ability to work across multiple microcontrollers Human-readable and easy-to-type (like Python)","title":"Features"},{"location":"#concept","text":"Lizard consists of individual hardware modules that are either defined in a persistent startup script or interactively via console input. Each module has a name, a number of required or optional constructor arguments and possibly a step function as well as a number of properties. Furthermore, Lizard allows to define rules , possibly asynchronous routines and variables . A routine is simply a collection of Lizard statements. If a rule's condition evaluates to true, the corresponding routine is started. Conditions can involve variables, module properties and constant expressions. One core module is automatically defined first. It provides interaction with the microcontroller itself, e.g. reading the system's time or causing a restart. During a main loop Lizard repeatedly performs the following tasks: Read and evaluate input from the serial interface. Run the step functions of each module. (The core module is evaluated last.) Check all rules and execute associated routines. Advance routines that are already running and waiting for certain conditions.","title":"Concept"},{"location":"examples/","text":"Examples \u00b6 Turn on an LED \u00b6 Create a new LED \"green\" at pin 14 and turn it on: green = Output(14) green.on() Read a button \u00b6 Create a button \"b1\" at pin 25 with internal pull-up resistor and read its value: b1 = Input(25) b1.pullup() b1.level Write a persistent startup script \u00b6 Clear the persistent storage, configure a button and an LED, write the new startup script to the persistent storage, restart the microcontroller with these two new modules and print the stored configuration: !- !+green = Output(14) !+b1 = Input(25) !. core.restart() !? Define a rule \u00b6 Create an LED \"red\", a button \"b1\" with pull-up resistor as well as a condition \"c1\" that turns off the LED as soon as the button is pressed: red = Output(14) red.on() b1 = Input(25) b1.pullup() when b1.level == 0 then red.off(); end Create a shadow module \u00b6 Create a \"green\" LED that shadows a \"red\" LED, i.e. will receive a copy of each command: green = Output(13) red = Output(14) red.shadow(green) Use a port expander \u00b6 Create a serial connection as well as a port expander with an LED at pin 15 and turn it on: serial = Serial(26, 27, 11500, 1) expander = Expander(serial, 32, 33) led = expander.Output(15) led.on()","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#turn-on-an-led","text":"Create a new LED \"green\" at pin 14 and turn it on: green = Output(14) green.on()","title":"Turn on an LED"},{"location":"examples/#read-a-button","text":"Create a button \"b1\" at pin 25 with internal pull-up resistor and read its value: b1 = Input(25) b1.pullup() b1.level","title":"Read a button"},{"location":"examples/#write-a-persistent-startup-script","text":"Clear the persistent storage, configure a button and an LED, write the new startup script to the persistent storage, restart the microcontroller with these two new modules and print the stored configuration: !- !+green = Output(14) !+b1 = Input(25) !. core.restart() !?","title":"Write a persistent startup script"},{"location":"examples/#define-a-rule","text":"Create an LED \"red\", a button \"b1\" with pull-up resistor as well as a condition \"c1\" that turns off the LED as soon as the button is pressed: red = Output(14) red.on() b1 = Input(25) b1.pullup() when b1.level == 0 then red.off(); end","title":"Define a rule"},{"location":"examples/#create-a-shadow-module","text":"Create a \"green\" LED that shadows a \"red\" LED, i.e. will receive a copy of each command: green = Output(13) red = Output(14) red.shadow(green)","title":"Create a shadow module"},{"location":"examples/#use-a-port-expander","text":"Create a serial connection as well as a port expander with an LED at pin 15 and turn it on: serial = Serial(26, 27, 11500, 1) expander = Expander(serial, 32, 33) led = expander.Output(15) led.on()","title":"Use a port expander"},{"location":"getting_started/","text":"Getting Started \u00b6 You launch an interactive shell with monitor.py to try out configurations. To verify that the communication is working, use one of the following commands to generate some output: core.info() core.millis core.print(\"Hello, Lizard!\") See the module reference for other commands. To try out individual modules, you can get their current properties or unmute them for continuous output, e.g.: estop = Input(34) estop.level estop.unmute()","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"You launch an interactive shell with monitor.py to try out configurations. To verify that the communication is working, use one of the following commands to generate some output: core.info() core.millis core.print(\"Hello, Lizard!\") See the module reference for other commands. To try out individual modules, you can get their current properties or unmute them for continuous output, e.g.: estop = Input(34) estop.level estop.unmute()","title":"Getting Started"},{"location":"language/","text":"The Lizard Language \u00b6 Statements \u00b6 Statements are input via the command-line interface or stored in the startup script on the microcontroller. The following statement types are currently supported. Expressions An expression can be a constant value, a variable, a module property, an arithmetic or logical expression as well as various combinations: true 42 3.14 \"Hello world\" led button.level 1 + (2 - 3 * 4)**5 1 == 2 or (x == 4 and button.level == 0) Expressions can be assigned to variables, used in conditions and passed to constructors, method calls or routine calls. Plain expression statements print their result to the command line. Variables: declaration and assignment New variables need to be explicitly declared with a data type: int i They can be immediately initialized: int i = 1 Otherwise they have an initial value of false , 0 , 0.0 or \"\" , respectively. Variables can be assigned a new value of compatible data type: i = 2 Modules: constructors, method calls and property assignments Constructors are used to create module instances: led = Output(15) See the module reference for more details about individual modules and their argument lists. Constructors can also be used with expander modules to instantiate a remote module that can be controlled from the main microcontroller: led = expander.Output(15) You can call module methods as follows: led.on() Some module properties are meant to be written to: motor.ratio = 9 Routines: definition and call Routines have a name and contain a list of actions: let all_on do green.on() red.on() end They can be called similar to module methods: all_on() Rules: definition Rules execute a list of actions when a condition is met: when button.level == 0 then core.print(\"Off!\") led.off() end In contrast to an if-statement known from other languages a when-condition is checked in every cycle of Lizard's main loop. Whenever the condition is true, the actions are executed. Note that actions can be asynchronous. If there are still actions running asynchronously, a truthy condition is ignored. Actions \u00b6 Routines and rules contain a list of actions. Method and routine calls Like with a method call statement, you can call methods and routines with an action: when clicked then core.print(\"On!\") all_on() end Property and variable assignments Like with the corresponding assignment statements, you can assign properties and variables with an action as well: when i > 0 then i = 0 core.debug = true end Await conditions and routines In contrast to statements, actions can await conditions, causing the execution of subsequent actions to wait until the condition is met. int t let blink do t = core.millis led.on() await core.millis > t + 1000 led.off() end Similarly, actions can await asynchronous routines, causing subsequent actions to wait until a routine is completed. when button.level == 0 then core.print(\"Blink...\") await blink() core.print(\"Done.\") end Data types \u00b6 Lizard currently supports five data types: Data type Example Range boolean bool b = true false , true integer number int i = 0 64-bit unsigned integer floating point number float f = 0.0 64-bit float string str s = \"foo\" identifier led = Output(15) Note that identifiers cannot be created via variable declarations, but only via constructors. Implicit conversion only happens from integers to floating point numbers: int i = 42 float f = i + 3.14 Whitespace, comments and line breaks \u00b6 Tabs and spaces are treated as whitespace. Blank lines are interpreted as no-op and do nothing. Line comments start with # . Multiple statements or actions are separated with ; or a newline. Control commands \u00b6 Lines with a leading ! can indicate one of the following control commands. Command Meaning !+abc Add abc to the startup script !-abc Remove lines starting with abc from the startup script !? Print the startup script !. Write the startup script to non-volatile storage !!abc Interpret abc as Lizard code !\"abc Print abc to the command-line Note that the commands !+ , !- and !? affect the startup script in RAM, which is only written to non-volatile storage with the !. command. Input from the default command-line interface UART0 is usually interpreted as Lizard code; input from a port expander is usually printed to the command-line on UART0. This behavior can be changed using !! and !\" .","title":"The Lizard Language"},{"location":"language/#the-lizard-language","text":"","title":"The Lizard Language"},{"location":"language/#statements","text":"Statements are input via the command-line interface or stored in the startup script on the microcontroller. The following statement types are currently supported. Expressions An expression can be a constant value, a variable, a module property, an arithmetic or logical expression as well as various combinations: true 42 3.14 \"Hello world\" led button.level 1 + (2 - 3 * 4)**5 1 == 2 or (x == 4 and button.level == 0) Expressions can be assigned to variables, used in conditions and passed to constructors, method calls or routine calls. Plain expression statements print their result to the command line. Variables: declaration and assignment New variables need to be explicitly declared with a data type: int i They can be immediately initialized: int i = 1 Otherwise they have an initial value of false , 0 , 0.0 or \"\" , respectively. Variables can be assigned a new value of compatible data type: i = 2 Modules: constructors, method calls and property assignments Constructors are used to create module instances: led = Output(15) See the module reference for more details about individual modules and their argument lists. Constructors can also be used with expander modules to instantiate a remote module that can be controlled from the main microcontroller: led = expander.Output(15) You can call module methods as follows: led.on() Some module properties are meant to be written to: motor.ratio = 9 Routines: definition and call Routines have a name and contain a list of actions: let all_on do green.on() red.on() end They can be called similar to module methods: all_on() Rules: definition Rules execute a list of actions when a condition is met: when button.level == 0 then core.print(\"Off!\") led.off() end In contrast to an if-statement known from other languages a when-condition is checked in every cycle of Lizard's main loop. Whenever the condition is true, the actions are executed. Note that actions can be asynchronous. If there are still actions running asynchronously, a truthy condition is ignored.","title":"Statements"},{"location":"language/#actions","text":"Routines and rules contain a list of actions. Method and routine calls Like with a method call statement, you can call methods and routines with an action: when clicked then core.print(\"On!\") all_on() end Property and variable assignments Like with the corresponding assignment statements, you can assign properties and variables with an action as well: when i > 0 then i = 0 core.debug = true end Await conditions and routines In contrast to statements, actions can await conditions, causing the execution of subsequent actions to wait until the condition is met. int t let blink do t = core.millis led.on() await core.millis > t + 1000 led.off() end Similarly, actions can await asynchronous routines, causing subsequent actions to wait until a routine is completed. when button.level == 0 then core.print(\"Blink...\") await blink() core.print(\"Done.\") end","title":"Actions"},{"location":"language/#data-types","text":"Lizard currently supports five data types: Data type Example Range boolean bool b = true false , true integer number int i = 0 64-bit unsigned integer floating point number float f = 0.0 64-bit float string str s = \"foo\" identifier led = Output(15) Note that identifiers cannot be created via variable declarations, but only via constructors. Implicit conversion only happens from integers to floating point numbers: int i = 42 float f = i + 3.14","title":"Data types"},{"location":"language/#whitespace-comments-and-line-breaks","text":"Tabs and spaces are treated as whitespace. Blank lines are interpreted as no-op and do nothing. Line comments start with # . Multiple statements or actions are separated with ; or a newline.","title":"Whitespace, comments and line breaks"},{"location":"language/#control-commands","text":"Lines with a leading ! can indicate one of the following control commands. Command Meaning !+abc Add abc to the startup script !-abc Remove lines starting with abc from the startup script !? Print the startup script !. Write the startup script to non-volatile storage !!abc Interpret abc as Lizard code !\"abc Print abc to the command-line Note that the commands !+ , !- and !? affect the startup script in RAM, which is only written to non-volatile storage with the !. command. Input from the default command-line interface UART0 is usually interpreted as Lizard code; input from a port expander is usually printed to the command-line on UART0. This behavior can be changed using !! and !\" .","title":"Control commands"},{"location":"machine_safety/","text":"Machine Safety \u00b6 Lizard implements the following features to increase machine safety. Checksums \u00b6 Each line sent via the command-line interface can and should be followed by a checksum. Lizard will omit any lines with incorrect checksums. Any output is as well sent with a checksum. The 8-bit checksum is computed as the bitwise XOR of all characters excluding the newline character and written as a two-digit hex number (with leading zeros) separated with an @ character, for example: Line Bitwise XOR Result 1 + 2 0x31 ^ 0x20 ^ 0x2b ^ 0x20 ^ 0x32 = 0x28 1 + 2@28 Keep-alive signal \u00b6 The core module provides a property last_message_age , which holds the time in milliseconds since the last input message was received from UART0, parsed and successfully interpreted. It allows formulating rules that stop critical hardware modules when the connection to the host system is lost. The following example stops a motor when there is no serial communication for 500 ms: when core.last_message_age > 500 then motor.stop(); end","title":"Machine Safety"},{"location":"machine_safety/#machine-safety","text":"Lizard implements the following features to increase machine safety.","title":"Machine Safety"},{"location":"machine_safety/#checksums","text":"Each line sent via the command-line interface can and should be followed by a checksum. Lizard will omit any lines with incorrect checksums. Any output is as well sent with a checksum. The 8-bit checksum is computed as the bitwise XOR of all characters excluding the newline character and written as a two-digit hex number (with leading zeros) separated with an @ character, for example: Line Bitwise XOR Result 1 + 2 0x31 ^ 0x20 ^ 0x2b ^ 0x20 ^ 0x32 = 0x28 1 + 2@28","title":"Checksums"},{"location":"machine_safety/#keep-alive-signal","text":"The core module provides a property last_message_age , which holds the time in milliseconds since the last input message was received from UART0, parsed and successfully interpreted. It allows formulating rules that stop critical hardware modules when the connection to the host system is lost. The following example stops a motor when there is no serial communication for 500 ms: when core.last_message_age > 500 then motor.stop(); end","title":"Keep-alive signal"},{"location":"module_reference/","text":"Module Reference \u00b6 All Lizard modules have the following methods in common. Methods Description module.mute() Turn output off module.unmute() Turn output on module.shadow() Send all method calls also to another module module.broadcast() Regularly send properties to another microcontroller (for internal use) Shadows are useful if multiple modules should behave exactly the same, e.g. two actuators that should always move synchronously. The broadcast method is used internally with port expanders . Core \u00b6 The core module encapsulates various properties and methods that are related to the microcontroller itself. It is automatically created right after the boot sequence. Properties Description Data type core.debug Whether to output debug information to the command line bool core.millis Time since booting the microcontroller (ms) int core.heap Free heap memory (bytes) int Methods Description Arguments core.restart() Restart the microcontroller core.info() Show lizard version and compile time core.print(...) Print arbitrary arguments to the command line arbitrary core.output(format) Define the output format str The output format is a string with multiple space-separated elements of the pattern <module>.<property>[:<precision>] or <variable>[:<precision>] . The precision is an optional integer specifying the number of decimal places for a floating point number. For example, the format \"core.millis input.level motor.position:3\" might yield an output like \"92456 1 12.789 . Bluetooth \u00b6 Lizard can receive messages via Bluetooth Low Energy. Simply create a Bluetooth module with a device name of your choice. Constructor Description Arguments bluetooth = Bluetooth(device_name) initialize bluetooth with advertised device_name str Lizard will offer a service 23014CCC-4677-4864-B4C1-8F772B373FAC and a characteristic 37107598-7030-46D3-B688-E3664C1712F0 that allows writing Lizard statements like on the command line. Input \u00b6 The input module is associated with a digital input pin that is be connected to a pushbutton, sensor or other input signal. Constructor Description Arguments input = Input(pin) pin is the corresponding GPIO number int Properties Description Data type input.level Current signal level (0 or 1) int input.change Level change since last cycle (-1..1) int Methods Description input.get() Output the current level input.pullup() Add an internal pull-up resistor input.pulldown() Add an internal pull-down resistor input.pulloff() Remove internal pull resistor Output \u00b6 The output module is associated with a digital output pin that is connected to an LED, actuator or other output signal. Constructor Description Arguments output = Output(pin) pin is the corresponding GPIO number int Properties Description Data type output.level Current signal level (0 or 1) int output.change Level change since last cycle (-1..1) int Methods Description Arguments output.on() Set the output pin high output.off() Set the output pin low output.level(value) Set the output level to the given value bool output.pulse(interval[, duty_cycle]) Switch output on and off float s The pulse() method allows pulsing an output with a given interval in seconds and an optional duty cycle between 0 and 1 (0.5 by default). Note that the pulsing frequency is limited by the main loop to around 20 Hz. MCP23017 Port Expander \u00b6 The MCP23017 allows controlling up to 16 general purpose input or output pins via I2C. Constructor Description Arguments mcp = Mcp23017([port[, sda[, scl[, address[, clk_speed]]]]]) See below int s The constructor expects up to five arguments: port : 0 or 1, since the ESP32 has two I2C ports (default: 0) sda : SDA pin (default: 21) scl : SCL pin (default: 22) address : client address of the MCP (0x20..0x28, default: 0x20) clk_speed : I2C clock speed (default: 100000) Properties Description Data type mcp.levels Levels of all 16 pins int mcp.inputs Input mode of all 16 pins int mcp.pullups Pull-up resistors for all 16 pins int The properties levels , inputs and pullups contain binary information for all 16 pins in form of a 16 bit unsigned integer. Methods Description Arguments mcp.levels(value) Set levels of all 16 pins int mcp.inputs(value) Set input mode of all 16 pins int mcp.pullups(value) Set pull-up resistors for all 16 pins int The methods levels() , inputs() and pullups() expect a 16 bit unsigned integer value containing binary information for all 16 pins. Use inputs() to configure input and output pins, e.g. inputs(0xffff) all inputs or inputs(0x0000) all outputs. While levels() will only affect output pins, pullups() will only affect the levels of input pins. Using an MCP23017 port expander module you can not only access individual pins. You can also instantiate the following modules passing the mcp instance as the first argument: Input: input = Input(mcp, pin) Output: output = Output(mcp, pin) Linear motor: motor = LinearMotor(mcp, move_in, move_out, end_in, end_out) The pins pin , move_in , move_out , end_in and end_out are numbers from 0 to 15 referring to A0...A7 and B0...B7 on the MCP23017. CAN interface \u00b6 The CAN module allows communicating with peripherals on the specified CAN bus. Constructor Description Arguments can = Can(rx, tx, baud) RX/TX pins and baud rate int , int , int Methods Description Arguments can.send(node_id, d0, d1, d2, d3, d4, d5, d6, d7) Send a frame with 8 data bytes 9x int can.get_status() Print the driver status can.start() Start the driver can.stop() Stop the driver can.recover() Recover the driver The method get_status() prints the following information: state (\"STOPPED\", \"RUNNING\", \"BUS_OFF\" or \"RECOVERING\"), msgs_to_tx , msgs_to_rx , tx_error_counter , rx_error_counter , tx_failed_count , rx_missed_count , rx_overrun_count , arb_lost_count and bus_error_count . After creating a CAN module, the driver is started automatically. The start() and stop() methods are primarily for debugging purposes. Serial interface \u00b6 The serial module allows communicating with peripherals via the specified connection. Constructor Description Arguments serial = Serial(rx, tx, baud, num) RX/TX pins, baud rate, UART number 4x int Methods Description Arguments serial.send(b0, b1, b2, ...) Send a number of bytes int s serial.read() Read and output current buffer This module might be used by other modules that communicate with peripherals via serial. You can, however, unmute the serial module to have incoming messages printed to the command line instead of keeping them buffered for other modules. Linear motor \u00b6 This module controls a linear actuator via two output pins (move in, move out) and two input pins reading two limit switches (end in, end out). Constructor Description Arguments motor = LinearMotor(move_in, move_out, end_in, end_out) motor control pins and limit switches 4x int Properties Description Data type motor.in Motor is in \"in\" position bool motor.out Motor is in \"out\" position bool Methods Description motor.in() Move in motor.out() Move out motor.stop() Stop motor ODrive Motor \u00b6 The ODrive motor module controls a motor using an ODrive motor controller . Constructor Description Arguments motor = ODriveMotor(can, can_id) CAN module and node ID CAN module, int Properties Description Data type motor.position Motor position (meters) float motor.tick_offset Encoder tick offset float motor.m_per_tick Meters per encoder tick float motor.reversed Reverse motor direction bool Methods Description Arguments motor.zero() Set current position as zero position motor.power(torque) Move with given torque float motor.speed(speed) Move with given speed (m/s) float motor.position(position) Move to given position (m) float motor.limits(speed, current) Set speed (m/s) and current (A) limits float , float motor.off() Turn motor off (idle state) ODrive Wheels \u00b6 The ODrive wheels module combines to ODrive motors and provides odometry and steering for differential wheeled robots. Constructor Description Arguments wheels = ODriveWheels(left_motor, left_motor) Two ODrive motor modules two ODrive motor modules Properties Description Data type wheels.width wheel distance (m) float wheels.linear_speed Forward speed (m/s) float wheels.angular_speed Turning speed (rad/s) float wheels.enabled Whether motors react to commands bool Methods Description Arguments wheels.power(left, right) Move with torque per wheel float , float wheels.speed(linear, angular) Move with linear / angular speed (m/s, rad/s) float , float wheels.off() Turn both motors off (idle state) When the wheels are not enabled , power and speed method calls are ignored. This allows disabling the wheels permanently by setting enabled = false in conjunction with calling the off() method. Now the vehicle can be pushed manually with motors turned off, without taking care of every line of code potentially re-activating the motors. RMD Motor \u00b6 The RMD motor module controls a Gyems RMD motor via CAN. Constructor Description Arguments rmd = RmdMotor(can, motor_id) CAN module and motor ID (1..8) CAN module, int Properties Description Data type rmd.position Multi-turn motor position (deg) float rmd.ratio Transmission from motor to shaft (default: 6) float rmd.torque Current torque float rmd.speed Current speed (deg/s) float rmd.can_age Time since last CAN message from motor (s) float rmd.map_distance Distance to leading motor (deg) float rmd.map_speed Computed speed to follow leading motor (deg/s) float Methods Description Arguments rmd.power(torque) Move with given torque (-32..32 A) float rmd.speed(speed) Move with given speed (deg/s) float rmd.position(pos) Move to and hold at pos (deg) float rmd.position(pos, speed) Move to and hold at pos (deg) with max. speed (deg/s) float , float rmd.stop() Stop motor (but keep operating state) rmd.resume() Resume motor (continue in state from before stop command) rmd.off() Turn motor off (clear operating state) rmd.hold() Hold current position rmd.map(leader) Map another RMD with current offset and scale 1 RMD module rmd.map(leader, m) Map another RMD with current offset and scale m RMD module, 1x float rmd.map(leader, m, n) Map another RMD with offset n and scale m RMD module, 2x float rmd.map(leader, a, b, c, d) Map another RMD from interval (a, b) to (c, d) RMD module, 4x float rmd.unmap() Stop mapping rmd.get_health() Print temperature (C), voltage (V) and error code rmd.get_pid() Print PID parameters Kp/Ki for position/speed/torque loop rmd.get_acceleration() Print acceleration setting rmd.set_acceleration() Set acceleration int rmd.clear_errors() Clear motor error rmd.zero() Write position to ROM as zero position (see below) The zero command The zero() method should be used with care! In contrast to other commands it blocks the main loop for up to 200 ms and requires restarting the motor to take effect. Furthermore, multiple writes will affect the chip life, thus it is not recommended to use it frequently. Mapping movement to another RMD motor When mapping the movement of a following motor to a leading motor, the follower uses velocity control to follow the leader. The follower's target speed is always computed such that it catches up within one loop cycle. When the following motor reaches its target position and the computed speed is below 1 degree per second, the follower switches to position control and holds the current position. The mapping interval ( a , b ) should not be empty, because the target position of the following motor would be undefined. Any method call (except the map() method) will unmap the motor. This avoids extreme position jumps and inconsistencies caused by multiple control loops running at the same time. RoboClaw \u00b6 The RoboClaw module serves as building block for more complex modules like RoboClaw motors. It communicates with a Basicmicro RoboClaw motor driver via serial. Constructor Description Arguments claw = RoboClaw(serial, address) Serial module and address Serial module, int RoboClaw Motor \u00b6 The RoboClaw motor module controls a motor using a RoboClaw module. Constructor Description Arguments motor = RoboClawMotor(claw, motor_id) RoboClaw module and motor ID (1..2) RoboClaw module, int Properties Description Data type motor.position Multi-turn motor position (encoder ticks) int Methods Description Arguments motor.power(torque) Move with given torque (-1..1) float motor.speed(speed) Move with given speed (-32767..32767) float motor.zero() Store position as zero position Stepper Motor \u00b6 The stepper motor module controls a stepper motor via \"step\" and \"direction\" pins. It uses the ESP LED Control API to generate pulses with sufficiently high frequencies and the Pulse Counter API to count steps. Constructor Description Arguments motor = StepperMotor(step, dir[, pu[, cp[, lt[, lc]]]]) Step and direction pins 6x int The constructor arguments pu (pulse counter unit), pc (pulse counter channel), lt (LED timer) and lc (LED channel) are optional and default to 0. When using multiple stepper motors, they can be set to different values to avoid conflicts. Properties Description Data type motor.position Motor position (steps) int motor.speed Motor speed (steps per second) int motor.idle Motor idle state bool Methods Description Arguments motor.speed(speed[, acceleration]) Move with given speed 2x float motor.position(position, speed[, acceleration]) Move to given position 3x float motor.stop() Stop The optional acceleration argument defaults to 0, which starts and stops pulsing immediately. CanOpenMaster \u00b6 The CanOpenMaster module sends periodic SYNC messages to all CANopen nodes. At creation, no messages are sent until sync_interval is set to a value greater than 0. Constructor Description Arguments co_master = CanOpenMaster(can) CAN module CAN module Properties Description Data type co_master.sync_interval Amount of lizard steps inbetween each SYNC int CanOpenMotor \u00b6 The CanOpenMotor module implements a subset of commands necessary to control a motor implementing DS402. Positional and velocity units are currently undefined and must by manually measured. Once the configuration sequence has finished, current status, position and velocity are queried on every SYNC. Constructor Description Arguments motor = CanOpenMotor(can, node_id) CAN module and node ID (1..127) CAN module , int Methods Description Arguments motor.enter_pp_mode(velo) Set 402 operating mode to profile position, halt off, and target velocity to velo int motor.enter_pv_mode() Set 402 operating mode to profile velocity, halt on, and target velocity to velo int motor.set_target_position(pos) Set target position to pos (signed). [pp mode] int motor.commit_target_position() Instruct motor to move to previously set target position. [pp mode] motor.set_target_velocity(velo) Set target velocity to velo . Absolute for pp mode, signed for pv mode int motor.set_ctrl_halt(mode) Latches / resets the \"halt\" bit and sends the updated control word to the node bool motor.set_ctrl_enable(mode) Latches / resets the \"enable operation\" bit and sends an updated control word to the node bool motor.reset_fault() Clear any faults (like positioning errors). Implicitly sets the \"halt\" bit. motor.sdo_read(index) Performs an SDO read at index index and sub index 0x00 int Properties Description Data type initialized Concurrent init sequence has finished, motor is ready bool last_heartbeat Time in \u00b5s since bootup when last heartbeat was received int is_booting Node is in booting state bool is_preoperational Node is in pre-operational state bool is_operational Node is in operational state bool actual_position Motor position at last SYNC int position_offset Offset implicitly added to target/reported position int actual_velocity Motor velocity at last SYNC int status_enabled Operation enabled bit of status word since last SYNC bool status_fault Fault bit of status word since last SYNC bool status_target_reached Target reached bit of status word since last SYNC bool ctrl_enable Latched operation enable bit of every sent control word bool ctrl_halt Latched halt bit of every sent control word bool Configuration sequence After creation of the module, the configuration is stepped through automatically on each heartbeat; once finished, the initialized attribute is set to true . Note that for runtime variables (actual position, velocity, and status bits) to be updated, a CanOpenMaster module must exist and be sending periodic SYNCs. Target position sequence Note: The target velocity must be positive regardless of target point direction. The halt bit is cleared when entering pp, though it can be set at any point during moves to effectively apply brakes. // First time, assuming motor is disabled and not in pp mode motor.set_ctrl_enable(true) motor.enter_pp_mode(<some positive velocity>) // All further set points only need these motor.set_target_position(<some position>) motor.commit_target_position() Target velocity sequence Unlike in the profile position mode, here the sign of the velocity does controls the direction. The halt bit is set when entering pv. To start moving, clear it (and set again to stop). // First time, assuming motor is disabled and not in pv mode motor.set_ctrl_enable(true) motor.enter_pv_mode(<some signed velocity>) // Further movements only need these motor.set_ctrl_halt(false) // await some condition motor.set_ctrl_halt(true) Expander \u00b6 The expander module allows communication with another microcontroller connected via serial . Constructor Description Arguments expander = Expander(serial, boot, enable) Serial module and boot/enable pins Serial module, 2x int Methods Description Arguments expander.run(command) Run any command on the other microcontroller string expander.disconnect() Disconnect serial connection and pins expander.flash() Flash other microcontroller with own binary data The disconnect() method might be useful to access the other microcontroller on UART0 via USB while still being physically connected to the main microcontroller. Note that the expander forwards all other method calls to the remote core module, e.g. expander.info() . Proxy \u00b6 -- This module is mainly for internal use with the expander module. -- Proxy modules serve as handles for remote modules running on another microcontroller. Declaring a module x = Proxy() will allow formulating rules like when x.level == 0 then ... . It will receive property values from a remote module with the same name x , e.g. an input signal level. Note that the remote module has to have turned on broadcasting: x.broadcast() . Constructor module = Proxy() Note that the proxy module forwards all method calls to the remote module.","title":"Module Reference"},{"location":"module_reference/#module-reference","text":"All Lizard modules have the following methods in common. Methods Description module.mute() Turn output off module.unmute() Turn output on module.shadow() Send all method calls also to another module module.broadcast() Regularly send properties to another microcontroller (for internal use) Shadows are useful if multiple modules should behave exactly the same, e.g. two actuators that should always move synchronously. The broadcast method is used internally with port expanders .","title":"Module Reference"},{"location":"module_reference/#core","text":"The core module encapsulates various properties and methods that are related to the microcontroller itself. It is automatically created right after the boot sequence. Properties Description Data type core.debug Whether to output debug information to the command line bool core.millis Time since booting the microcontroller (ms) int core.heap Free heap memory (bytes) int Methods Description Arguments core.restart() Restart the microcontroller core.info() Show lizard version and compile time core.print(...) Print arbitrary arguments to the command line arbitrary core.output(format) Define the output format str The output format is a string with multiple space-separated elements of the pattern <module>.<property>[:<precision>] or <variable>[:<precision>] . The precision is an optional integer specifying the number of decimal places for a floating point number. For example, the format \"core.millis input.level motor.position:3\" might yield an output like \"92456 1 12.789 .","title":"Core"},{"location":"module_reference/#bluetooth","text":"Lizard can receive messages via Bluetooth Low Energy. Simply create a Bluetooth module with a device name of your choice. Constructor Description Arguments bluetooth = Bluetooth(device_name) initialize bluetooth with advertised device_name str Lizard will offer a service 23014CCC-4677-4864-B4C1-8F772B373FAC and a characteristic 37107598-7030-46D3-B688-E3664C1712F0 that allows writing Lizard statements like on the command line.","title":"Bluetooth"},{"location":"module_reference/#input","text":"The input module is associated with a digital input pin that is be connected to a pushbutton, sensor or other input signal. Constructor Description Arguments input = Input(pin) pin is the corresponding GPIO number int Properties Description Data type input.level Current signal level (0 or 1) int input.change Level change since last cycle (-1..1) int Methods Description input.get() Output the current level input.pullup() Add an internal pull-up resistor input.pulldown() Add an internal pull-down resistor input.pulloff() Remove internal pull resistor","title":"Input"},{"location":"module_reference/#output","text":"The output module is associated with a digital output pin that is connected to an LED, actuator or other output signal. Constructor Description Arguments output = Output(pin) pin is the corresponding GPIO number int Properties Description Data type output.level Current signal level (0 or 1) int output.change Level change since last cycle (-1..1) int Methods Description Arguments output.on() Set the output pin high output.off() Set the output pin low output.level(value) Set the output level to the given value bool output.pulse(interval[, duty_cycle]) Switch output on and off float s The pulse() method allows pulsing an output with a given interval in seconds and an optional duty cycle between 0 and 1 (0.5 by default). Note that the pulsing frequency is limited by the main loop to around 20 Hz.","title":"Output"},{"location":"module_reference/#mcp23017-port-expander","text":"The MCP23017 allows controlling up to 16 general purpose input or output pins via I2C. Constructor Description Arguments mcp = Mcp23017([port[, sda[, scl[, address[, clk_speed]]]]]) See below int s The constructor expects up to five arguments: port : 0 or 1, since the ESP32 has two I2C ports (default: 0) sda : SDA pin (default: 21) scl : SCL pin (default: 22) address : client address of the MCP (0x20..0x28, default: 0x20) clk_speed : I2C clock speed (default: 100000) Properties Description Data type mcp.levels Levels of all 16 pins int mcp.inputs Input mode of all 16 pins int mcp.pullups Pull-up resistors for all 16 pins int The properties levels , inputs and pullups contain binary information for all 16 pins in form of a 16 bit unsigned integer. Methods Description Arguments mcp.levels(value) Set levels of all 16 pins int mcp.inputs(value) Set input mode of all 16 pins int mcp.pullups(value) Set pull-up resistors for all 16 pins int The methods levels() , inputs() and pullups() expect a 16 bit unsigned integer value containing binary information for all 16 pins. Use inputs() to configure input and output pins, e.g. inputs(0xffff) all inputs or inputs(0x0000) all outputs. While levels() will only affect output pins, pullups() will only affect the levels of input pins. Using an MCP23017 port expander module you can not only access individual pins. You can also instantiate the following modules passing the mcp instance as the first argument: Input: input = Input(mcp, pin) Output: output = Output(mcp, pin) Linear motor: motor = LinearMotor(mcp, move_in, move_out, end_in, end_out) The pins pin , move_in , move_out , end_in and end_out are numbers from 0 to 15 referring to A0...A7 and B0...B7 on the MCP23017.","title":"MCP23017 Port Expander"},{"location":"module_reference/#can-interface","text":"The CAN module allows communicating with peripherals on the specified CAN bus. Constructor Description Arguments can = Can(rx, tx, baud) RX/TX pins and baud rate int , int , int Methods Description Arguments can.send(node_id, d0, d1, d2, d3, d4, d5, d6, d7) Send a frame with 8 data bytes 9x int can.get_status() Print the driver status can.start() Start the driver can.stop() Stop the driver can.recover() Recover the driver The method get_status() prints the following information: state (\"STOPPED\", \"RUNNING\", \"BUS_OFF\" or \"RECOVERING\"), msgs_to_tx , msgs_to_rx , tx_error_counter , rx_error_counter , tx_failed_count , rx_missed_count , rx_overrun_count , arb_lost_count and bus_error_count . After creating a CAN module, the driver is started automatically. The start() and stop() methods are primarily for debugging purposes.","title":"CAN interface"},{"location":"module_reference/#serial-interface","text":"The serial module allows communicating with peripherals via the specified connection. Constructor Description Arguments serial = Serial(rx, tx, baud, num) RX/TX pins, baud rate, UART number 4x int Methods Description Arguments serial.send(b0, b1, b2, ...) Send a number of bytes int s serial.read() Read and output current buffer This module might be used by other modules that communicate with peripherals via serial. You can, however, unmute the serial module to have incoming messages printed to the command line instead of keeping them buffered for other modules.","title":"Serial interface"},{"location":"module_reference/#linear-motor","text":"This module controls a linear actuator via two output pins (move in, move out) and two input pins reading two limit switches (end in, end out). Constructor Description Arguments motor = LinearMotor(move_in, move_out, end_in, end_out) motor control pins and limit switches 4x int Properties Description Data type motor.in Motor is in \"in\" position bool motor.out Motor is in \"out\" position bool Methods Description motor.in() Move in motor.out() Move out motor.stop() Stop motor","title":"Linear motor"},{"location":"module_reference/#odrive-motor","text":"The ODrive motor module controls a motor using an ODrive motor controller . Constructor Description Arguments motor = ODriveMotor(can, can_id) CAN module and node ID CAN module, int Properties Description Data type motor.position Motor position (meters) float motor.tick_offset Encoder tick offset float motor.m_per_tick Meters per encoder tick float motor.reversed Reverse motor direction bool Methods Description Arguments motor.zero() Set current position as zero position motor.power(torque) Move with given torque float motor.speed(speed) Move with given speed (m/s) float motor.position(position) Move to given position (m) float motor.limits(speed, current) Set speed (m/s) and current (A) limits float , float motor.off() Turn motor off (idle state)","title":"ODrive Motor"},{"location":"module_reference/#odrive-wheels","text":"The ODrive wheels module combines to ODrive motors and provides odometry and steering for differential wheeled robots. Constructor Description Arguments wheels = ODriveWheels(left_motor, left_motor) Two ODrive motor modules two ODrive motor modules Properties Description Data type wheels.width wheel distance (m) float wheels.linear_speed Forward speed (m/s) float wheels.angular_speed Turning speed (rad/s) float wheels.enabled Whether motors react to commands bool Methods Description Arguments wheels.power(left, right) Move with torque per wheel float , float wheels.speed(linear, angular) Move with linear / angular speed (m/s, rad/s) float , float wheels.off() Turn both motors off (idle state) When the wheels are not enabled , power and speed method calls are ignored. This allows disabling the wheels permanently by setting enabled = false in conjunction with calling the off() method. Now the vehicle can be pushed manually with motors turned off, without taking care of every line of code potentially re-activating the motors.","title":"ODrive Wheels"},{"location":"module_reference/#rmd-motor","text":"The RMD motor module controls a Gyems RMD motor via CAN. Constructor Description Arguments rmd = RmdMotor(can, motor_id) CAN module and motor ID (1..8) CAN module, int Properties Description Data type rmd.position Multi-turn motor position (deg) float rmd.ratio Transmission from motor to shaft (default: 6) float rmd.torque Current torque float rmd.speed Current speed (deg/s) float rmd.can_age Time since last CAN message from motor (s) float rmd.map_distance Distance to leading motor (deg) float rmd.map_speed Computed speed to follow leading motor (deg/s) float Methods Description Arguments rmd.power(torque) Move with given torque (-32..32 A) float rmd.speed(speed) Move with given speed (deg/s) float rmd.position(pos) Move to and hold at pos (deg) float rmd.position(pos, speed) Move to and hold at pos (deg) with max. speed (deg/s) float , float rmd.stop() Stop motor (but keep operating state) rmd.resume() Resume motor (continue in state from before stop command) rmd.off() Turn motor off (clear operating state) rmd.hold() Hold current position rmd.map(leader) Map another RMD with current offset and scale 1 RMD module rmd.map(leader, m) Map another RMD with current offset and scale m RMD module, 1x float rmd.map(leader, m, n) Map another RMD with offset n and scale m RMD module, 2x float rmd.map(leader, a, b, c, d) Map another RMD from interval (a, b) to (c, d) RMD module, 4x float rmd.unmap() Stop mapping rmd.get_health() Print temperature (C), voltage (V) and error code rmd.get_pid() Print PID parameters Kp/Ki for position/speed/torque loop rmd.get_acceleration() Print acceleration setting rmd.set_acceleration() Set acceleration int rmd.clear_errors() Clear motor error rmd.zero() Write position to ROM as zero position (see below) The zero command The zero() method should be used with care! In contrast to other commands it blocks the main loop for up to 200 ms and requires restarting the motor to take effect. Furthermore, multiple writes will affect the chip life, thus it is not recommended to use it frequently. Mapping movement to another RMD motor When mapping the movement of a following motor to a leading motor, the follower uses velocity control to follow the leader. The follower's target speed is always computed such that it catches up within one loop cycle. When the following motor reaches its target position and the computed speed is below 1 degree per second, the follower switches to position control and holds the current position. The mapping interval ( a , b ) should not be empty, because the target position of the following motor would be undefined. Any method call (except the map() method) will unmap the motor. This avoids extreme position jumps and inconsistencies caused by multiple control loops running at the same time.","title":"RMD Motor"},{"location":"module_reference/#roboclaw","text":"The RoboClaw module serves as building block for more complex modules like RoboClaw motors. It communicates with a Basicmicro RoboClaw motor driver via serial. Constructor Description Arguments claw = RoboClaw(serial, address) Serial module and address Serial module, int","title":"RoboClaw"},{"location":"module_reference/#roboclaw-motor","text":"The RoboClaw motor module controls a motor using a RoboClaw module. Constructor Description Arguments motor = RoboClawMotor(claw, motor_id) RoboClaw module and motor ID (1..2) RoboClaw module, int Properties Description Data type motor.position Multi-turn motor position (encoder ticks) int Methods Description Arguments motor.power(torque) Move with given torque (-1..1) float motor.speed(speed) Move with given speed (-32767..32767) float motor.zero() Store position as zero position","title":"RoboClaw Motor"},{"location":"module_reference/#stepper-motor","text":"The stepper motor module controls a stepper motor via \"step\" and \"direction\" pins. It uses the ESP LED Control API to generate pulses with sufficiently high frequencies and the Pulse Counter API to count steps. Constructor Description Arguments motor = StepperMotor(step, dir[, pu[, cp[, lt[, lc]]]]) Step and direction pins 6x int The constructor arguments pu (pulse counter unit), pc (pulse counter channel), lt (LED timer) and lc (LED channel) are optional and default to 0. When using multiple stepper motors, they can be set to different values to avoid conflicts. Properties Description Data type motor.position Motor position (steps) int motor.speed Motor speed (steps per second) int motor.idle Motor idle state bool Methods Description Arguments motor.speed(speed[, acceleration]) Move with given speed 2x float motor.position(position, speed[, acceleration]) Move to given position 3x float motor.stop() Stop The optional acceleration argument defaults to 0, which starts and stops pulsing immediately.","title":"Stepper Motor"},{"location":"module_reference/#canopenmaster","text":"The CanOpenMaster module sends periodic SYNC messages to all CANopen nodes. At creation, no messages are sent until sync_interval is set to a value greater than 0. Constructor Description Arguments co_master = CanOpenMaster(can) CAN module CAN module Properties Description Data type co_master.sync_interval Amount of lizard steps inbetween each SYNC int","title":"CanOpenMaster"},{"location":"module_reference/#canopenmotor","text":"The CanOpenMotor module implements a subset of commands necessary to control a motor implementing DS402. Positional and velocity units are currently undefined and must by manually measured. Once the configuration sequence has finished, current status, position and velocity are queried on every SYNC. Constructor Description Arguments motor = CanOpenMotor(can, node_id) CAN module and node ID (1..127) CAN module , int Methods Description Arguments motor.enter_pp_mode(velo) Set 402 operating mode to profile position, halt off, and target velocity to velo int motor.enter_pv_mode() Set 402 operating mode to profile velocity, halt on, and target velocity to velo int motor.set_target_position(pos) Set target position to pos (signed). [pp mode] int motor.commit_target_position() Instruct motor to move to previously set target position. [pp mode] motor.set_target_velocity(velo) Set target velocity to velo . Absolute for pp mode, signed for pv mode int motor.set_ctrl_halt(mode) Latches / resets the \"halt\" bit and sends the updated control word to the node bool motor.set_ctrl_enable(mode) Latches / resets the \"enable operation\" bit and sends an updated control word to the node bool motor.reset_fault() Clear any faults (like positioning errors). Implicitly sets the \"halt\" bit. motor.sdo_read(index) Performs an SDO read at index index and sub index 0x00 int Properties Description Data type initialized Concurrent init sequence has finished, motor is ready bool last_heartbeat Time in \u00b5s since bootup when last heartbeat was received int is_booting Node is in booting state bool is_preoperational Node is in pre-operational state bool is_operational Node is in operational state bool actual_position Motor position at last SYNC int position_offset Offset implicitly added to target/reported position int actual_velocity Motor velocity at last SYNC int status_enabled Operation enabled bit of status word since last SYNC bool status_fault Fault bit of status word since last SYNC bool status_target_reached Target reached bit of status word since last SYNC bool ctrl_enable Latched operation enable bit of every sent control word bool ctrl_halt Latched halt bit of every sent control word bool Configuration sequence After creation of the module, the configuration is stepped through automatically on each heartbeat; once finished, the initialized attribute is set to true . Note that for runtime variables (actual position, velocity, and status bits) to be updated, a CanOpenMaster module must exist and be sending periodic SYNCs. Target position sequence Note: The target velocity must be positive regardless of target point direction. The halt bit is cleared when entering pp, though it can be set at any point during moves to effectively apply brakes. // First time, assuming motor is disabled and not in pp mode motor.set_ctrl_enable(true) motor.enter_pp_mode(<some positive velocity>) // All further set points only need these motor.set_target_position(<some position>) motor.commit_target_position() Target velocity sequence Unlike in the profile position mode, here the sign of the velocity does controls the direction. The halt bit is set when entering pv. To start moving, clear it (and set again to stop). // First time, assuming motor is disabled and not in pv mode motor.set_ctrl_enable(true) motor.enter_pv_mode(<some signed velocity>) // Further movements only need these motor.set_ctrl_halt(false) // await some condition motor.set_ctrl_halt(true)","title":"CanOpenMotor"},{"location":"module_reference/#expander","text":"The expander module allows communication with another microcontroller connected via serial . Constructor Description Arguments expander = Expander(serial, boot, enable) Serial module and boot/enable pins Serial module, 2x int Methods Description Arguments expander.run(command) Run any command on the other microcontroller string expander.disconnect() Disconnect serial connection and pins expander.flash() Flash other microcontroller with own binary data The disconnect() method might be useful to access the other microcontroller on UART0 via USB while still being physically connected to the main microcontroller. Note that the expander forwards all other method calls to the remote core module, e.g. expander.info() .","title":"Expander"},{"location":"module_reference/#proxy","text":"-- This module is mainly for internal use with the expander module. -- Proxy modules serve as handles for remote modules running on another microcontroller. Declaring a module x = Proxy() will allow formulating rules like when x.level == 0 then ... . It will receive property values from a remote module with the same name x , e.g. an input signal level. Note that the remote module has to have turned on broadcasting: x.broadcast() . Constructor module = Proxy() Note that the proxy module forwards all method calls to the remote module.","title":"Proxy"},{"location":"tools/","text":"Tools \u00b6 Interaction \u00b6 Serial monitor \u00b6 Use the serial monitor to read the current output and interactively send Lizard or control commands to the microcontroller. ./monitor.py [<device_path>] You can also use an SSH monitor to access a microcontroller via SSH: ./monitor_ssh.sh <user@host> Note that the serial monitor cannot communicate while the serial interface is busy communicating with another process. Configure script \u00b6 Use the configure script to send a new startup script to the microcontroller. ./configure.py <config_file> <device_path> Note that the configure script cannot communicate while the serial interface is busy communicating with another process. Development \u00b6 Compile script \u00b6 After making changes to the Lizard language definition or its C++ implementation, you can use the compile script to generate a new parser and executing the compilation in an Espressif IDF Docker container. ./compile.sh Upload new firmware \u00b6 To upload the compiled firmware you can use one of the following scripts. Upload via USB \u00b6 ./upload_usb.sh [<device_path>] Upload via SSH \u00b6 ./upload_ssh.sh <user@host> Upload via ttyTHS1 \u00b6 ./upload_ths1.sh This script is useful on Robot Brains where the microcontroller is connected to the pin header of an NVIDIA Jetson computer. Backtrace \u00b6 In case Lizard terminates with a backtrace printed to the serial terminal, you can use the following script to print corresponding source code lines. ./backtrace.sh <addresses> Note that the script assumes Espressif IDF tools being installed at ~/esp/esp-tools_4.2/ and a compiled ELF file being located at build/lizard.elf .","title":"Tools"},{"location":"tools/#tools","text":"","title":"Tools"},{"location":"tools/#interaction","text":"","title":"Interaction"},{"location":"tools/#serial-monitor","text":"Use the serial monitor to read the current output and interactively send Lizard or control commands to the microcontroller. ./monitor.py [<device_path>] You can also use an SSH monitor to access a microcontroller via SSH: ./monitor_ssh.sh <user@host> Note that the serial monitor cannot communicate while the serial interface is busy communicating with another process.","title":"Serial monitor"},{"location":"tools/#configure-script","text":"Use the configure script to send a new startup script to the microcontroller. ./configure.py <config_file> <device_path> Note that the configure script cannot communicate while the serial interface is busy communicating with another process.","title":"Configure script"},{"location":"tools/#development","text":"","title":"Development"},{"location":"tools/#compile-script","text":"After making changes to the Lizard language definition or its C++ implementation, you can use the compile script to generate a new parser and executing the compilation in an Espressif IDF Docker container. ./compile.sh","title":"Compile script"},{"location":"tools/#upload-new-firmware","text":"To upload the compiled firmware you can use one of the following scripts.","title":"Upload new firmware"},{"location":"tools/#upload-via-usb","text":"./upload_usb.sh [<device_path>]","title":"Upload via USB"},{"location":"tools/#upload-via-ssh","text":"./upload_ssh.sh <user@host>","title":"Upload via SSH"},{"location":"tools/#upload-via-ttyths1","text":"./upload_ths1.sh This script is useful on Robot Brains where the microcontroller is connected to the pin header of an NVIDIA Jetson computer.","title":"Upload via ttyTHS1"},{"location":"tools/#backtrace","text":"In case Lizard terminates with a backtrace printed to the serial terminal, you can use the following script to print corresponding source code lines. ./backtrace.sh <addresses> Note that the script assumes Espressif IDF tools being installed at ~/esp/esp-tools_4.2/ and a compiled ELF file being located at build/lizard.elf .","title":"Backtrace"}]}